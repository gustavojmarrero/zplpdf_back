import { Injectable, Logger, NotFoundException, BadRequestException } from '@nestjs/common';
import { FirestoreService } from '../../cache/firestore.service.js';
import { ExchangeRateService } from './exchange-rate.service.js';
import type {
  Expense,
  ExpenseCategory,
  ExpenseType,
  RecurrenceType,
} from '../../../common/interfaces/finance.interface.js';

export interface CreateExpenseDto {
  amount: number;
  currency: 'usd' | 'mxn';
  type: ExpenseType;
  category: ExpenseCategory;
  description: string;
  vendor?: string;
  recurrenceType?: RecurrenceType;
  date?: Date | string;
  // Campos de suscripción del servicio contratado
  subscriptionStartDate?: string;
  subscriptionEndDate?: string;
  autoRenewal?: boolean;
}

export interface UpdateExpenseDto {
  amount?: number;
  currency?: 'usd' | 'mxn';
  category?: ExpenseCategory;
  description?: string;
  vendor?: string;
  recurrenceType?: RecurrenceType;
  // Campos de suscripción del servicio contratado
  subscriptionStartDate?: string;
  subscriptionEndDate?: string;
  autoRenewal?: boolean;
}

export interface ExpenseFilters {
  startDate?: Date;
  endDate?: Date;
  category?: ExpenseCategory;
  type?: ExpenseType;
  page?: number;
  limit?: number;
}

@Injectable()
export class ExpenseService {
  private readonly logger = new Logger(ExpenseService.name);

  constructor(
    private readonly firestoreService: FirestoreService,
    private readonly exchangeRateService: ExchangeRateService,
  ) {}

  /**
   * Crea un nuevo gasto
   */
  async createExpense(data: CreateExpenseDto, adminEmail: string): Promise<Expense> {
    // Validar datos
    if (data.amount <= 0) {
      throw new BadRequestException('Amount must be greater than 0');
    }

    if (data.type === 'recurring' && !data.recurrenceType) {
      throw new BadRequestException('Recurring expenses must have a recurrence type');
    }

    // Convertir a MXN si es necesario
    let amountMxn = data.amount;
    let exchangeRate = 1;

    if (data.currency === 'usd') {
      try {
        const conversion = await this.exchangeRateService.convertUsdToMxn(
          data.amount,
          this.firestoreService,
        );
        amountMxn = conversion.amountMxn;
        exchangeRate = conversion.rate;
      } catch (error) {
        this.logger.warn(`Failed to get exchange rate: ${error.message}`);
        exchangeRate = 20; // Fallback
        amountMxn = data.amount * exchangeRate;
      }
    }

    const expenseId = this.generateExpenseId();
    const now = data.date ? new Date(data.date) : new Date();

    // Calcular próxima fecha de generación para gastos recurrentes
    let nextGenerationDate: Date | undefined;
    if (data.type === 'recurring' && data.recurrenceType) {
      nextGenerationDate = this.calculateNextGenerationDate(now, data.recurrenceType);
    }

    // Build expense object, excluding undefined values (Firestore doesn't accept undefined)
    const expense: Expense = {
      id: expenseId,
      amount: data.amount,
      currency: data.currency,
      amountMxn,
      exchangeRate,
      type: data.type,
      category: data.category,
      description: data.description,
      createdBy: adminEmail,
      createdAt: now,
      isAutoGenerated: false,
      // Only include optional fields if they have values
      ...(data.vendor && { vendor: data.vendor }),
      ...(data.recurrenceType && { recurrenceType: data.recurrenceType }),
      ...(nextGenerationDate && { nextGenerationDate }),
      // Campos de suscripción
      ...(data.subscriptionStartDate && { subscriptionStartDate: new Date(data.subscriptionStartDate) }),
      ...(data.subscriptionEndDate && { subscriptionEndDate: new Date(data.subscriptionEndDate) }),
      ...(data.autoRenewal !== undefined && { autoRenewal: data.autoRenewal }),
    };

    await this.firestoreService.saveExpense(expense);
    this.logger.log(`Created expense: ${expenseId}`);

    return expense;
  }

  /**
   * Actualiza un gasto existente
   */
  async updateExpense(id: string, data: UpdateExpenseDto): Promise<Expense> {
    const { expenses } = await this.firestoreService.getExpenses({ limit: 1 });
    const existingExpense = expenses.find((e) => e.id === id);

    if (!existingExpense) {
      throw new NotFoundException(`Expense ${id} not found`);
    }

    // Si cambia el monto o la moneda, recalcular MXN
    let amountMxn = existingExpense.amountMxn;
    let exchangeRate = existingExpense.exchangeRate;

    if (data.amount !== undefined || data.currency !== undefined) {
      const newAmount = data.amount ?? existingExpense.amount;
      const newCurrency = data.currency ?? existingExpense.currency;

      if (newCurrency === 'usd') {
        try {
          const conversion = await this.exchangeRateService.convertUsdToMxn(
            newAmount,
            this.firestoreService,
          );
          amountMxn = conversion.amountMxn;
          exchangeRate = conversion.rate;
        } catch (error) {
          exchangeRate = 20;
          amountMxn = newAmount * exchangeRate;
        }
      } else {
        amountMxn = newAmount;
        exchangeRate = 1;
      }
    }

    // Extraer campos de suscripción para procesarlos por separado
    const { subscriptionStartDate, subscriptionEndDate, autoRenewal, ...restData } = data;

    const updateData: Partial<Expense> = {
      ...restData,
      amountMxn,
      exchangeRate,
      updatedAt: new Date(),
      // Campos de suscripción (convertir fechas a Date si vienen)
      ...(subscriptionStartDate && { subscriptionStartDate: new Date(subscriptionStartDate) }),
      ...(subscriptionEndDate && { subscriptionEndDate: new Date(subscriptionEndDate) }),
      ...(autoRenewal !== undefined && { autoRenewal }),
    };

    await this.firestoreService.updateExpense(id, updateData);
    this.logger.log(`Updated expense: ${id}`);

    return {
      ...existingExpense,
      ...updateData,
    } as Expense;
  }

  /**
   * Elimina un gasto
   */
  async deleteExpense(id: string): Promise<void> {
    await this.firestoreService.deleteExpense(id);
    this.logger.log(`Deleted expense: ${id}`);
  }

  /**
   * Obtiene lista de gastos con filtros
   */
  async getExpenses(filters: ExpenseFilters): Promise<{
    expenses: Expense[];
    total: number;
    pagination: { page: number; limit: number; totalPages: number };
  }> {
    const page = filters.page || 1;
    const limit = filters.limit || 50;

    const result = await this.firestoreService.getExpenses({
      startDate: filters.startDate,
      endDate: filters.endDate,
      category: filters.category,
      type: filters.type,
      page,
      limit,
    });

    return {
      expenses: result.expenses,
      total: result.total,
      pagination: {
        page,
        limit,
        totalPages: Math.ceil(result.total / limit),
      },
    };
  }

  /**
   * Obtiene resumen de gastos por período
   */
  async getExpenseSummary(
    startDate: Date,
    endDate: Date,
  ): Promise<{
    total: number;
    totalMxn: number;
    byCategory: Record<string, { amount: number; percentage: number }>;
    byType: { recurring: number; one_time: number };
    topVendors: Array<{ vendor: string; amount: number }>;
  }> {
    const summary = await this.firestoreService.getExpenseSummary(startDate, endDate);

    // Calcular porcentajes por categoría
    const byCategory: Record<string, { amount: number; percentage: number }> = {};
    for (const [category, amount] of Object.entries(summary.byCategory)) {
      byCategory[category] = {
        amount,
        percentage: summary.totalMxn > 0 ? (amount / summary.totalMxn) * 100 : 0,
      };
    }

    // Obtener top vendors
    const { expenses } = await this.firestoreService.getExpenses({ startDate, endDate, limit: 500 });
    const vendorTotals = new Map<string, number>();

    for (const expense of expenses) {
      if (expense.vendor) {
        vendorTotals.set(
          expense.vendor,
          (vendorTotals.get(expense.vendor) || 0) + expense.amountMxn,
        );
      }
    }

    const topVendors = Array.from(vendorTotals.entries())
      .map(([vendor, amount]) => ({ vendor, amount }))
      .sort((a, b) => b.amount - a.amount)
      .slice(0, 10);

    return {
      total: summary.total,
      totalMxn: summary.totalMxn,
      byCategory,
      byType: summary.byType,
      topVendors,
    };
  }

  /**
   * Genera gastos recurrentes que vencen hoy (llamado por cron)
   */
  async generateRecurringExpenses(): Promise<{ generated: number }> {
    const recurringExpenses = await this.firestoreService.getRecurringExpensesDueToday();
    let generated = 0;

    for (const parentExpense of recurringExpenses) {
      try {
        // Obtener tipo de cambio actualizado
        let amountMxn = parentExpense.amount;
        let exchangeRate = 1;

        if (parentExpense.currency === 'usd') {
          try {
            const conversion = await this.exchangeRateService.convertUsdToMxn(
              parentExpense.amount,
              this.firestoreService,
            );
            amountMxn = conversion.amountMxn;
            exchangeRate = conversion.rate;
          } catch {
            exchangeRate = 20;
            amountMxn = parentExpense.amount * exchangeRate;
          }
        }

        // Crear nuevo gasto
        const newExpenseId = this.generateExpenseId();
        const now = new Date();

        const newExpense: Expense = {
          id: newExpenseId,
          amount: parentExpense.amount,
          currency: parentExpense.currency,
          amountMxn,
          exchangeRate,
          type: 'one_time', // Los generados son únicos
          category: parentExpense.category,
          description: `${parentExpense.description} (auto-generado)`,
          vendor: parentExpense.vendor,
          parentExpenseId: parentExpense.id,
          createdBy: 'system',
          createdAt: now,
          isAutoGenerated: true,
        };

        await this.firestoreService.saveExpense(newExpense);

        // Actualizar próxima fecha de generación del gasto padre
        const nextDate = this.calculateNextGenerationDate(now, parentExpense.recurrenceType!);
        await this.firestoreService.updateExpense(parentExpense.id, {
          nextGenerationDate: nextDate,
        });

        generated++;
        this.logger.log(`Generated recurring expense: ${newExpenseId} from ${parentExpense.id}`);
      } catch (error) {
        this.logger.error(`Failed to generate expense from ${parentExpense.id}: ${error.message}`);
      }
    }

    return { generated };
  }

  // ============================================
  // Helper Methods
  // ============================================

  private generateExpenseId(): string {
    const now = new Date();
    const dateStr = now.toISOString().slice(0, 10).replace(/-/g, '');
    const random = Math.random().toString(36).substring(2, 7).toUpperCase();
    return `expense_${dateStr}_${random}`;
  }

  private calculateNextGenerationDate(fromDate: Date, recurrenceType: RecurrenceType): Date {
    const nextDate = new Date(fromDate);

    if (recurrenceType === 'monthly') {
      nextDate.setMonth(nextDate.getMonth() + 1);
    } else if (recurrenceType === 'annual') {
      nextDate.setFullYear(nextDate.getFullYear() + 1);
    }

    return nextDate;
  }
}
